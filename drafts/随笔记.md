- sklearn
- numpy
- pandas

# 画ROC曲线

ROC曲线中，希望输入的预测值应该是概率，而不是取`argmax`之后的结果。**本例是在类平衡的情况下做的**

1. 首先计算导入必须的包

   ```python
   from sklearn.metrics import RocCurveDisplay
   from sklearn.metrics import roc_curve
   from sklearn.metrics import auc
   from sklearn.metrics import roc_auc_score
   import numpy as np
   from sklearn.preprocessing import OneHotEncoder
   ```

2. 计算假阳率和真阳率

   ```python
   y_true = np.array(
       [[1., 0., 0.],
        [0., 1., 0.],
        [1., 0., 0.],
        [0., 0., 1.],
        [1., 0., 0.],
        [0., 1., 0.]]
   )
   
   y_pred = np.array(
       [[0.6, 0.2, 0.2],
       [0.1, 0.7, 0.2],
       [0.4, 0.3, 0.2],
       [0.1, 0.1, 0.8],
       [0.2, 0.7, 0.1],
       [0.3, 0.6, 0.1]]
   )
   
   # roc_curve只适用于二分类情形，这里我们将多分类情形转换为二分类情形，
   # 简单来说，就是将y_ture和y_pred拉直。拉直之后就可以用roc_curve了
   false_pos_rate, true_pos_rate, _ = roc_curve(y_ture.ravel(), y_pred.ravel())
   ```

3. 计算auc

   AUC的计算有以下两种，一般来说，如果y_pred使用的是概率值，那么它们得到的结果应该是一样的。

   ```python
   auc1 = roc_auc_score(y_ture.ravel(), y_pred.ravel())
   auc2 = auc(false_pos_rate, true_pos_rate)
   ```

4. 画ROC曲线

   画曲线这部分把假阳率和真阳率传入就可以了

   ```python
   roc = RocCurveDisplay(fpr=false_pos_rate, tpr=true_pos_rate, roc_auc=auc1)
   roc.plot()
   ```


# 模型训练的惨痛教训

1. 最近在训练深度分类模型，数据只有划分好的训练集和测试集，然后在训练的过程中我根据模型在测试集上的表现选择性的对模型进行保存，由于没有用测试集上的数据对模型进行参数更新，给我一种模型没有受到测试集经验影响的错觉。实际上，这样的一个过程中已经利用测试集对模型进行了选择。在训练过程中，测试集上的指标就像是模型努力的目标，指导模型朝着特定的方向努力。这显然会使得训练出来的模型在测试集上表现的过于乐观。

# SimCLR的数据增强

SimCLR-v2的数据增强同SimCLR的数据增强相同。具体的内容参考原文。

```python
def rnd_crop(output_size):
    return transforms.RandomResizedCrop(output_size)


def rnd_color_distortion(s=1.0):
    color_jitter = transforms.ColorJitter(0.8*s, 0.8*s, 0.8*s, 0.2*s)
    rnd_color_jitter = transforms.RandomApply([color_jitter], p=0.8)
    rnd_gray = transforms.RandomGrayscale(p=0.2)
    return transforms.Compose([
        rnd_color_jitter,
        rnd_gray
    ])


def rnd_gaussian_blur(kernel_size=23, p=0.5, sigma=(0.1, 2.0)):
    # kernel size must be odd
    kernel_size = kernel_size if kernel_size % 2 != 0 else kernel_size+1
    gauss_blur = transforms.RandomApply(
        [transforms.GaussianBlur(kernel_size, sigma)], p)
    return gauss_blur


def simclr_data_aug(output_size, s=1.0):
    """
    Args:
        output_size: same as the input size.
        s:
    """
    return transforms.Compose([
        rnd_crop(output_size),
        rnd_color_distortion(s),
        rnd_gaussian_blur(int(output_size*0.1))
    ])
```

# Pytorch求K近邻

```python
def top_knn(feature, k):
    """
    Args:
        feature (torch.Tensor): dimension is (batch_size, feature_dim)
        k (int):
    """
    sim = f.normalize(feature, dim=1) @ f.normalize(feature, dim=1).T
    max_val, idx = torch.topk(sim, k+1, dim=1)
    return [feature[idx[:, i]] for i in range(1, idx.shape[1])]
```

# 对比学习相关优化目标

## RINCE

```python
def rince_loss(batch_1, batch_2, q, t, lam, neg_mask):
    """assume batch_1 and batch_2 are normalized.
    Args:
        batch_1 (torch.Tensor): a batch feature
        batch_2 (torch.Tensor): a batch feature
        q (float): hyper-parameter
        t (float): temperature parameter
        lam (float): hyper-parameter
        neg_mask (torch.Tensor): shape should be (2*batch_1.shape[0], batch_1.shape[1])
    """
    # compute neg score
    batch_all = torch.cat([batch_1, batch_2], dim=0)
    sim = torch.exp(torch.matmul(batch_all, batch_all.T) / t)
    neg = torch.sum(sim * neg_mask, dim=1)

    # compute pos score
    pos = torch.exp(torch.sum(batch_1 * batch_2, dim=1) / t)
    pos = torch.cat([pos, pos], dim=0)

    # sum
    part1 = -(pos**q) / q
    part2 = (lam * (pos + neg)**q) / q
    return part1.mean() + part2.mean()
```

# Linux常用

## Vim

**快速跳到指定行：** `:n`

**替换指定的字符串：** `:start_row,endrows/oldstr/newstr/g`。endrow和s表示两个不同的意思

## wget

谷歌云盘分享的链接的格式一般为：`https://drive.google.com/file/d/<fileid>/view`。

- fileid是文件在服务器上的表示
- filename是文件的名字
- --load-cookies：加载cookies
- --no-check-certificate：连接某些网站的时候可能不安全，这时候不用检查证书
- --quite：或者用-q关闭wget的输出
- -save-cookies：将cookies保存至某个路径

```bash
#!/bin/bash

# cd scratch place
cd data/

# Download zip dataset from Google Drive
filename='xxx.zip'
fileid='xxx'
wget --load-cookies /tmp/cookies.txt "https://drive.google.com/uc?export=download&confirm=$(wget --quiet --save-cookies /tmp/cookies.txt --keep-session-cookies --no-check-certificate 'https://drive.google.com/uc?export=download&id=${fileid}' -O- | sed -rn 's/.confirm=([0-9A-Za-z_]+)./\1\n/p')&id=${fileid}" -O ${filename} && rm -rf /tmp/cookies.txt

# Unzip
unzip -q ${filename}
rm ${filename}
cd
```

## 文本处理

### cut

用于显示每行中指定范围内的字符。

- -c：以字符为单位指定范围。查看每行的第2到5个字符：`cut -c 2-5`
- -b：以字节为单位指定范围
- -d：指定分隔符。一般结合-f使用
- -f：以field为单位指定范围。划分field的分隔符使用-d来指定。查看使用分号分隔的文件的每行的第2列到最后一列：`cut -d ';' -f 2-`

### head

查看文本头部的一些内容

- -c：以字符为单位指定查看的头部的范围。查看前20个字符：`head -c 20`
- -n：以行为单位指定查看的头部的范围。查看前20行：`head -n 20`

### tail

查看文件尾部的一些内容

- -c：以字符为单位指定查看的尾部的范围。查看尾部20个字符：`tail -c 20`
- -n：以行为单位指定查看的尾部的范围。查看尾20行：`tail -n 20`
- 查看某段文本第20字符到第100个字符：`head -c 100 | tail -c 81`

### tr

`tr oldstr newstr`。将旧串替换成新串

- -d：指定删除那些字符
- -s：缩减连续重复的字符成指定的单个字符。如：将多个空格替换成单个空格：`tr -s ' '`

### sort

`sort $1`。排序一段文本

- -r：逆序排序
- -n：按照数值大小排序
- -t：指定排序时的分隔符。比如，根据第二列进行排序：`sort -t $'\t' -k 2`
- -k：指定排序时所依赖的field。

### uniq

`uniq $1`。对一段文本去重

- -c：统计非重复单词的个数。
- -i：忽略大小写。
- -u：仅显示出一次的行列。

### paste

指令会把每个文件以列对列的方式，一列列地加以合并。

- -d：指定间隔符
- -s：可以理解为，合并的时候，每个文件内部先利用间隔符进行合并，然后再把不同的文件合并起来。

## 数组

1. **查看数组的所有元素：** `echo ${a[@]}`

2. **查看数组的长度：** `echo ${#a[@]}`

2. **数组遍历**。遍历第3到第8个元素。闭区间：

   **使用for循环**

   ```bash
   arr=($(cat))
   for i in {3..8}; do
       printf '%s ' "${arr[$i]}"
   done
   ```

   **使用echo**

   ```bash
   arr=($(cat))
   echo ${arr[@]:3:5}  # 5表示取5个元素
   ```


## grep

用于查找符合一定范式要求的文本内容

- 查找有python字符的文本：`grep python`
- 查找出现python单词的文本：`grep -w python`。-w用于指定匹配整个单词
- -i：用于忽略大小写
- -v：--inverse-match。用于指定不可以包含的模式或单词
- -E：将字符串延伸为正则表达式来用

## sed

sed是用于快速解析和转换文本的工具。

例：将文本中第一个editor替换为tool，`sed -e s/editor/tool/`

例：将文本中所有的editor替换为tool，`sed -e s/editor/tool/g`

例：将文本中第二个editor替换为tool，`sed -e s/editor/tool/2`

例：将文本中的editor用花括号包装起来，`sed -e s/editor/{&}/g`

- -e：表示以指定的脚本来处理指定文件的内容
- `sed -e s/the/this/ig`：在忽略大小写的情况下，将文本中所有的the替换为this。

## awk

awk可用于许多需要快速编写脚本的文本处理和数据处理任务

