## Lab 0 Docker及课程环境配置

仍然参考课程给出的<a href="https://docs.docker.com/engine/install/ubuntu/">链接</a>

我并没有旧版本的Docker，直接进入安装。关于卸载旧版本的Docker这个文档中也给出了详细的指导。

#### 设置仓库

安装一些必要的包，允许apt通过https来使用仓库

```
sudo apt-get update
 
sudo apt-get install \
    ca-certificates \
    curl \
    gnupg \
    lsb-release
```

添加Docker官方的GPG密钥：

```
sudo mkdir -p /etc/apt/keyrings

curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
```

使用下面的命令设置仓库。（由于我的是linuxmint，和官方不同的是，我吧$(lsb_release -cs) 改成了 focal）

```
echo \
 "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
  focal stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
```

#### 安装Docker引擎

```
sudo apt-get update

sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin
```

查看docker的版本：

```
sudo docker version
```

查看docker的信息

```
sudo docker info
```

运行HelloWord

```
sudo docker hello-world
```

**至此Docker安装成功！以上内容大都抄自官网**

#### 课程环境配置

创建一个放课程文件的目录（比如说csci0300）：

```
mkdir csci0300
```

。克隆课程给的开发环境：(ssh或者https都可以，后面的course-env可以自己指定名称)

```
git clone git@github.com:csci0300/cs300-s22-devenv.git course-env
```

进入docker目录

```
cd course-env/docker

ls
# cs300-build-docker  Dockerfile  Dockerfile.arm64  README.md  sources.list
```

作为国内用户，使用GitHub仓库中提供的sources.list实在是问题百出。这里我把sources.list改了一下。讲sources.list里面的内容全部清除，换成清华源的链接，然后sources.list内容如下：

```
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu focal main restricted universe multiverse
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu focal-updates main restricted universe multiverse
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu focal-backports main restricted universe multiverse
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse
```

然后修改Dockerfile，在FROM，下面添加下面两行代码：

```
ADD sources.list
RUN apt-get update
```

然后build即可：

```
sudo ./cs300-build-docker
```

build成功之后沿着做后面的任务，没有什么特别的地方了。

#### 文本编辑器

我使用的是vim，搭配neovim。

```
# 首先安装neovim
sudo apt install neovim

# C语言，c++的自动补全功能，安装ccls
sudo apt install ccls
```

安装plug.vim，<a href="https://github.com/junegunn/vim-plug">GitHub</a>

```
sh -c 'curl -fLo "${XDG_DATA_HOME:-$HOME/.local/share}"/nvim/site/autoload/plug.vim --create-dirs \
       https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
```

然后进行配置：

```
# 在home下新建目录 '.config/nvim'，在此目录下创建两个文件coc-settings.json, init.vim
mkdir .config
mkdir .config/nvim
touch coc-settings.json
touch init.vim
```

coc-settings.json的内容：

```
{
"languageserver": {
  "ccls": {
    "command": "ccls",
    "filetypes": ["c", "cc", "cpp", "c++", "objc", "objcpp"],
    "rootPatterns": [".ccls", "compile_commands.json", ".git/", ".hg/"],
    "initializationOptions": {
        "cache": {
          "directory": "/tmp/ccls"
        }
      }
  }
}
}
```

init.vim的内容：

```
set number
syntax on
set rnu " Show Relative line number

call plug#begin()
    Plug 'neoclide/coc.nvim', {'branch': 'release'}
    Plug 'joshdick/onedark.vim'
call plug#end()
colorscheme onedark

set expandtab
set softtabstop=4


" File encoding method
set encoding=utf-8

" Some servers have issues with backup files, see #649.
set nobackup
set nowritebackup

" Having longer updatetime (default is 4000 ms = 4 s) leads to noticeable
" delays and poor user experience.
set updatetime=300

" Always show the signcolumn, otherwise it would shift the text each time
" diagnostics appear/become resolved.
set signcolumn=yes

" Use tab for trigger completion with characters ahead and navigate.
" NOTE: There's always complete item selected by default, you may want to enable
" no select by `"suggest.noselect": true` in your configuration file.
" NOTE: Use command ':verbose imap <tab>' to make sure tab is not mapped by
" other plugin before putting this into your config.
inoremap <silent><expr> <TAB>
      \ coc#pum#visible() ? coc#pum#next(1) :
      \ CheckBackspace() ? "\<Tab>" :
      \ coc#refresh()
inoremap <expr><S-TAB> coc#pum#visible() ? coc#pum#prev(1) : "\<C-h>"

" Make <CR> to accept selected completion item or notify coc.nvim to format
" <C-g>u breaks current undo, please make your own choice.
inoremap <silent><expr> <CR> coc#pum#visible() ? coc#pum#confirm()
                              \: "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"

function! CheckBackspace() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

" Use <c-space> to trigger completion.
if has('nvim')
  inoremap <silent><expr> <c-space> coc#refresh()
else
  inoremap <silent><expr> <c-@> coc#refresh()
endif

" Use `[g` and `]g` to navigate diagnostics
" Use `:CocDiagnostics` to get all diagnostics of current buffer in location list.
nmap <silent> [g <Plug>(coc-diagnostic-prev)
nmap <silent> ]g <Plug>(coc-diagnostic-next)

" GoTo code navigation.
nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gy <Plug>(coc-type-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)

set cursorline
set cursorcolumn
hi CursorLine   cterm=NONE ctermbg=237 ctermfg=white guibg=darkred
hi CursorColumn cterm=NONE ctermbg=237 ctermfg=white guibg=darkred
hi Pmenu ctermfg=NONE ctermbg=237
hi PmenuSel ctermfg=NONE ctermbg=31


" Status Line
set laststatus=2
hi User1 ctermbg=green ctermfg=red guibg=green guifg=red
set statusline=%F%m%r%h%w%=\ [ft=%Y]\ %{\"[fenc=\".(&fenc==\"\"?&enc:&fenc).((exists(\"+bomb\")\ &&\ &bomb)?\"+\":\"\").\"]\"}\ [ff=%{&ff}]\ [asc=%03.3b]\ [hex=%02.2B]\ [pos=%04l,%04v][%p%%]\ [len=%L]


"补全括号和花括号（换行四次）
:inoremap ( ()<ESC>i
":inoremap ) <c-r>=ClosePair(')')<CR>
:inoremap { {<CR>}<ESC>O
:inoremap } <c-r>=ClosePair('}')<CR>
:inoremap [ []<ESC>i
:inoremap ] <c-r>=ClosePair(']')<CR>
:inoremap " ""<ESC>i
:inoremap ' ''<ESC>i

let g:coc_disable_startup_warning = 1
```

OK，安装语言的LSP可以参考这里：<a href="https://github.com/neoclide/coc.nvim/wiki/Language-servers">GitHub</a>。

。。。。

还需要安装nodejs。<a href="https://phoenixnap.com/kb/update-node-js-version">更新nodejs</a>

```
sudo apt install nodejs

# 通过npm 更新到最新版
sudo apt install npm  # 安装npm
npm cache clean -f   # 清除缓存
npm install -g n  # 安装node版本管理器
sudo n lastest
```

OK，至此就可以使用nvim来编辑文件了，或许可以给nvim起个别名，比如nv

## lab 3 汇编语言

函数调用的过程。（下面几条是个人的总结，对新手很不友好。具体参考 <a href="https://cs.brown.edu/courses/csci0300/2022/assign/labs/lab3.html">Walk through the x86-64 Call Stack.</a>）

1. `call` 指令会将`call`指令的下一条指令的地址压入到栈中。实际上这就是返回地址。然后让`rip`寄存器中存储被调函数的代码的地址。
2. 进入到被调函数后，`rbp`的值（也就是celler函数的栈帧的基址）会被压入到栈中，做一下暂存,`push %rbp`。然后将`rsp`寄存器的值，也就是当前（cellee函数的栈帧的基址）存入到`rbp`。此时rbp里面存储的是callee函数的基址。至此就完成了新的调用栈帧的开辟。
3. 扩展栈，为局部变量开辟存储空间。执行callee函数的操作。
4. 执行完毕后，`mov %rbp,%rsp`将当前callee函数的栈帧基址放入到`rsp`。此时callee函数栈帧的基址就是栈顶，也就完成了新开辟栈帧的回收。` pop %rbp `，将栈顶元素（此时的栈顶元素是caller函数的栈帧的基址，第2步暂存的）弹出，并放入到`rbp`中。此时的栈顶元素将是返回地址。
5. `retq`，调用完毕，返回。这将把栈顶元素弹出，放入到`rip`寄存器中。这时就开始执行`call`指令的下一条指令。

### Traps

这部分主要是考察对汇编代码的理解。理解了函数调用过程和一些常用指令的作用就可以很轻松的做出来了。值得注意的是`$0x1`表示立即数（它代表数值1，不代表地址或者其他的意义）。

### Buffer Overflow

这部分重点在于理解函数的调用过程，栈帧中局部变量的布局。

值得注意的是32字节的缓冲区的分配的空间并不是32字节，这部分可以从汇编代码中发现。清楚了实验中缓冲区的栈帧布局，就可以很快的定位到哪里是我们需要修改的常量了。尤其注意要使用小端法表示。

关于Overflow2，从返回地址上考虑。搞清楚foo函数栈帧的布局，就能找到返回地址的位置，然后将hack函数的地址填入到返回地址。这样当foo执行完，在返回的时候，就会直接返回到hack函数而不是main函数。

## lab 4 Cache Todo







## lab 6 Processes

这个lab的目的是让我们熟悉一下多进程编程。总共有两部分，第一部分是做一个简单的shell，它能够运行一些简单的命令。第二部分是使用多进程编程来实现一个词频统计的程序，程序框架已经搭好，我们只需要实现核心的部分。

第一部分主要是熟悉`fork`和`execv`两个系统调用搭配使用的方法。在早期学习的时候，我被告知fork是用来创建进程的，由于我之前使用过GitHub的fork，它可以fork一份完全一样的仓库到自己的账户，我一直很奇怪，这种现象和创建进程有什么关系？现在一切都明了了，创建进程时，操作系统会将父进程的状态复制一份作为一个新的子进程，这显然和GitHub的fork现象是一致的。而`execv`系统调用用于执行一个新的程序，它会把从父进程复制的进程镜像（虚拟地址空间，包括代码区，全局变量区，栈和堆）用需要执行的程序的进程镜像替换。结合这两个系统调用来实现一个简单的Shell。

第二部分比较复杂，学习过多线程的话，对这部分上手较快。基本的逻辑就是，一个父进程用来分发任务，每个子进程负责执行一个特定的任务，这里所谓的任务就是在一个文件内搜索一个给定的单词。整体的逻辑是很清晰的，但是在实现细节上会有很多需要注意的地方：

- 我们需要保证对每个进程给定了正确的待搜索的文件名。可以使用一个当前该处理的文件的索引来处理。
- 关于父进程和子进程之间的通信。实际上，父进程和每个子进程之间都有一个管道。这个并不难理解。
- 子进程主要负责执行`process_file`函数，因此不要忘了退出。
- 序列化只序列化了`indexes`和`phrases`。`count`实际上等于`indexes.size()`。`filename`实际上可以不进行序列化，在我的实现中就没有对它进行序列化，这并不会影响最终结果的正确性。也可以进行序列化，一个方法就是计算`filename`所占字节的大小，然后把所占字节大小（这通常是一个4字节的数）写入管道，然后对`filename`序列化并写入管道。在读的时候，我们先读4个字节，比如说值是`fn_len`，这是`filename`的长度，然后再入`fn_len`个字节就得到了`filename`。
- 关于`indexes`和`phrases`的序列化。父进程读取的时候如何知道要从管道中读取多少内容（不包括`filename`）？注意到官方给定的反序列化的函数中是使用`buf[i] != '\0'`来判断是否已经序列化了所有的字节。这也就是说我们的管道中的最后一个字节应该是`'\0'`，因此，在写的时候就要尤其注意。我先把序列化后的字符串转换成了一个字符数组，并且这个字符数组的长度比字符串大1，因为它需要额外的一个字节来保存`'\0'`。在这种情况下，向管道中写入这个字符数组的内容即可。
- 最容易犯的一个还是申请了内存不要忘记归还。

## lab 7 Threads

在多进程程序中，每个进程独自拥有进程镜像。实际上，每个进程内也可以并发执行，这就有了线程。同一进程内的线程共享内存地址空间，但是每个线程拥有自己的栈空间。

相对于lab6而言，这个lab是比较容易的。整体逻辑和lab6基本一样，我们需要做的就是创建线程，并给它需要执行的函数和参数，然后等待线程执行完毕再进行统计结果即可。

## lab 8 Safer Systems Programming (featuring Rust)

在之前使用c/c++编程的过程中，我们需要手动申请堆内存，并负责释放申请的内存。如果不释放的话，那么在程序结束后操作系统负责回收堆内存。此外，我们还很容易遇到缓冲区溢出，返回局部变量的指针等问题。Rust是一种更加安全的语言，当我们写下了内存管理的错误时，Rust在编译时就会指出我们的错误，而不是等到运行时出现异常的结果。

这个lab中首先展示了Rust对释放后使用，返回局部变量的指针，并发编程的安全保护。并没有很复杂的地方，并发部分和channel通信部分可以参考The Rust Programming Language第16章来完成。

## lab 9 Protobuf and gRPC

我们通过socket系统调用来进行不同机器之间的通信。机器与机器之间的通信是通过字节流实现的，因此我们需要在客户端（请求端）编写编码请求信息的逻辑，需要在服务端（接收端）编写解码请求信息的逻辑。实际上，在服务端我们也需要编写编码响应信息的逻辑，在客户端要编写解码相应信息的逻辑。Protobuf是一个用来指定编码解码规范的框架，使用这个框架可以使我们不必关注信息编码和解码的细节。gRPC是一个RPC的代码生成工具（第一次接触这两个工具，理解还不够深刻）。使用这两个工具可以为我们提供极大的便利。这个Lab主要是展示这两个工具的用法。

Protobuf 文件的书写可以参考这个<a href="https://developers.google.com/protocol-buffers/docs/reference/cpp-generated">文档</a>。尤其要注意为message或者结构所生成的API。另外，还要定义ToDoManager服务，其中包含三个`rpc`：`AddToDo`,`EditTodo`,`GetTodos`。每个`rpc`必须有且只有一个参数和一个返回值。实际上这个参数就是生存的代码中的`request`，而返回值就是生成代码中的`response`。

实现`todo_client.cc`和`todo_server.cc`中的`TODO`部分时，逻辑也很简单。主要就是要熟悉生成的代码的API。下面有几种常用的API使用方式：

- `request->title()`。从request中取`title`的值，如果是获取`xxx`的值，那就是`request->xxx()`
- `response->set_success()`。为`response`的`success`域设定值。如果是`xxx`属性的话，那就是`response->set_xxx()`。
- `response->items(i)`。获取`repeated`属性的第i个元素。
- `proto::TodoStatus_Name(i)`。获取`enum`类型值`i`对应的名字。
- 更具体的内容参考<a href="https://developers.google.com/protocol-buffers/docs/reference/cpp-generated">文档</a>。

****

## Project 1 Snake

贪吃蛇项目，代码框架已经写好，实现思路也设计好了，从易到难，逐渐扩展功能。

**1、初始化游戏**

初始化游戏有三个内容。初始化游戏状态，初始化board，初始化snake。

初始化游戏状态主要就是初始化游戏是否已经结束，初始化游戏的得分。这部分比较容易。

初始化board，这是一个比较困难的地方。board有两种初始化方式，当没有提供board的字符表示的时候，采用默认的初始化方式。当提供了board的字符表示时，采用提供的字符进行初始化。默认的初始化方式是已经给定的。解析字符串的方法，我借鉴了编译原理的词法解析的流水线方式。读字符，匹配，解析。

初始化snake，snake容易出现的错误就是内存泄露。snake一开始只需要实现简单的不变长的字符就可以，但最终需要扩展成可变长的snake。可变长的snake使用链表保存snake的位置。链表的操作方法在lab2中都已经实现好了。但是建议增加一个方法，实现对链表的清空，完成内存的释放，避免内存泄露。snake的增长操作（grow函数），实现也很容易，只需将food出现的位置插入到snake的位置链表中，然后将board上food的标志改成snake的标志。（每次吃到food只增长一分，snake只增长一格）。snake的移动操作（move函数）也很容易，我的snake的位置链表中，头部结点表示头的位置，尾部结点表示尾的位置。每次移动的时候，只需要将尾部结点移除（注意free掉内存），然后在头部结点插入到下次移动到的位置。然后修改board上的标志即可。

**2、放置食物**

放置事物的函数已经实现好了，逻辑也很简单

**3、更新board的状态**

更新board的状态可以分为两步：根据用户的输入计算下一次的位置，判断此次移动是否成功，然后修改snake。

计算下一次的位置并不复杂，需要注意的是，snake不能回首咬到自己。也就是说，当snake向右移动的时候，若用户输入向左移动的指令，那么snake应该继续向右移动，而不对这个指令做出回应。

判断此次移动是否成功。

- 如果下个位置是墙体，那么就结束游戏。
- 如果下个位置普通的cell，那么移动snake即可。
- 如果下个位置是食物，那么就要吃掉食物。（为了兼容snake的简单版本，游戏有增长snake和不增长snake两种方式），吃掉食物后，如果需要增长snake，那么执行已经实现的grow函数。如果不需要增长snake，那么就要移动snake，指定move函数。当然，还要放置下一个食物。
- 如果下个位置是snake，当然就game over了。这里有个特殊的情况，如果先计算下次的位置，后移动snake的话，那么就会出现，如果下个位置是snake刚要离开的位置，但是由于还没有执行move操作，所以下个位置上还是snake，这就要区别考虑

**4、mbslen函数**

该函数的作用是求多字节字符串的长度。使用位运算的方式，首先回去第一个bit的值，如果是0的话，那么当前的这个字节就表示一个字符。若不是0的话，那么这就是多字节的字符。然后取高4bit的值。若值在[192,224)（`[110x, 1110)`）之间，那么接下来的两个字节就表示一个字符。如果值在[224, 240)（`[1110, 1111)`），那么接下来的三个字节就表示一个字符。若高4bit的值等于240，那么接下来的4个字节就表示一个字符。

## Project 2 Dmalloc

在这个项目中，我们会实现一个叫dmalloc的程序。这个程序具有下面的功能：

- 追踪动态内存分配的信息
- 捕获常见的内存使用错误（两次回收内存，尝试分配过多的内存）
- 检测越界写的错误

![image-20220930193445253](https://cdn.jsdelivr.net/gh/AllenWrong/BlogCDN/img/image-20220930193445253.png)

`0x7f`是边界值。中间空白部分是分配空间。底部是8个字节的额外空间，`size of alloc`占四个字节是分配空间的大小。`AllocF`是分配标志，占两个字节。

#### `get_statistics`实现

这个比较容易，在dmalloc文件中定义几个全局变量，用于追踪已分配的内存的信息，释放的内存的信息。当前活跃的内存信息是使用总分配的减掉释放的计算出来的。

#### 整数溢出保护

由于需要开辟额外的内存用来存放metadata。因此直接想到的就是利用无符号整数溢出，值会变小来判断。我额外开辟了8个字节用来存放metadata。当size+8小于size的时候，就发生了整数溢出。然后将分配失败的个数加1。

#### 无效释放内存

这里我主要是根据hints来实现的。定义全局变量heap_max,heap_min用来追踪堆中已分配的大致的地址和最小的地址。如果要求释放的内存地址不在这个范围内，那就是无效的释放。这里只能追踪简单的无效释放的情况。

#### double-free

metadata数据占用了额外的8个字节。不妨将这8个字节的地址称为：0,1,2,3,4,5,6,7。其中0,1,2,3四个字节用来存放当前分配的堆内存块的大小。4,5两字节用来存放内存分配的标志。这个标志是使用分配出去的内存块的基址的低2个字节加上一个常数来表示的。`(unsigned long long)p & 0xffff+3`表示当前内存块已分配。`(unsigned long long)p & 0xffff+2`表示当前内存块已释放。4,5两个字节存储的值不是这两个值，说明内存块是未分配的。因此这也可以检测释放未分配的内存的错误。

在free的时候，拿到metadata中存放分配标志的值，若是`(unsigned long long)p & 0xffff+2`则遇到了double-free的情况。

#### 越界写检测

由于实验中只需要做到检测简单的边界写错误，因此这里的实现比较简单。在开辟内存的时候，除了多开辟额外的8字节用于存储metadata，再多开辟一个字节用于存储边界值，该值我用的是`0x7f`。比如：要求分配的大小为sz，那么我会要求分配sz+8+1的空间。如果得到的基址为b，那么b+8才是真正返回的基址，这8个字节用于存储metadata。b+8+sz用于存储边界值`0x7f`。

当在释放内存的时候，拿到待释放基址`ptr`，`ptr+sz`中的内容就是边界值，如果边界值不是`0xff`，那么这时就发生了越界写的错误。

**释放内存的时候，一定要给的是metadata的基址，即((char*)ptr-8)**

#### 内存泄露报告

主要是实现函数print_leak_report()。基本的思路就是使用map来记录分配的基址和大小。然后再记录一下文件名和行号即可。程序结束后，如果内存块活跃的个数不为0，那么就说明有内存泄露。然后遍历打印map中的内容。

#### 高级的检测

为什么我使用地址的第四位加上一个常量值来做内存分配标志。一开始我使用的是1,2来区分。但这无法通过test032。所以依赖于地址的话，可以通过test032。test033是一个更狂野的情况。他把b的metadata复制走之后，然后把b释放了，然后又把b的metadata复制过去，接着再进行释放。显然，内存分配标志信息意味着这个内存已分配还没被回收。但是这块内存确实已经回收了。于是，再判断一下这个基址是否在分配的map中即可。若不在说明发生了这个狂野的错误。

#### Extra Credit

有时间再补充吧，这部分没做。

## Project 4 WeensyOS

**两个debug技巧**

- 再次检查你对概念的理解。阅读你写的代码，确保你真的理解了代码的逻辑。
- 使用`log_printf`系统调用来打印系统运行的日志。

