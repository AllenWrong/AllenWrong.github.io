```Java
ant test
```

Hint

- Header中的bit是从低位开始的。如表示只有一个元组存在时用1表示（0000 0001）而不是(1000 0000)。

1、SeqScan。

**Lab1**

TupleDesc

- `public Iterator<TDItem> iterator()`：
- `public TupleDesc(Type[] typeAr, String[] fieldAr)`：
- `public TupleDesc(Type[] typeAr)`：
- `public int numFields()`：
- `public String getFieldName(int i)`：
- `public Type getFieldType(int i)`：
- `public int fieldNameToIndex(String name)`：
- `public int getSize()`：
- `public static TupleDesc merge(TupleDesc td1, TupleDesc td2)`：
- `public boolean equals(Object o)`:
- `public String toString()`：

Tuple

- `public Tuple(TupleDesc td)`：
- `public TupleDesc getTupleDesc()`：
- `public RecordId getRecordId()`：
- `public void setRecordId(RecordId rid)`：
- `public void setField(int i, Field f)`：
- `public Field getField(int i)`：
- `public String toString()`：
- `public Iterator<Field> fields()`：
- `public void resetTupleDesc(TupleDesc td)`：

Catalog

- `public Catalog()`：
- `public void addTable(DbFile file, String name, String pkeyField)`：
- `public int getTableId(String name)`：
- `public TupleDesc getTupleDesc(int tableid)`：
- `public DbFile getDatabaseFile(int tableid)`：
- `public String getPrimaryKey(int tableid)`：
- `public Iterator<Integer> tableIdIterator()`：
- `public String getTableName(int id)`：
- `public void clear()`：

BufferPool

- `public BufferPool(int numPages)`：
- `public  Page getPage(TransactionId tid, PageId pid, Permissions perm)`：

HeapPageId

- `public HeapPageId(int tableId, int pgNo)`：
- `public int getTableId()`：
- `public int getPageNumber()`：
- `public int hashCode()`：
- `public boolean equals(Object o)`：

RecordId

HeapPage

HeapFile

SeqScan

**Lab2**

Predicate

- `public Predicate(int field, Op op, Field operand)`：
- `public int getField()`:
- `public Op getOp()`：
- `public Field getOperand()`：
- `public boolean filter(Tuple t)`：
- `public String toString()`：

JoinPredicate

- `public JoinPredicate(int field1, Predicate.Op op, int field2)`：
- `public boolean filter(Tuple t1, Tuple t2)`：
- `public int getField1()`：
- `public int getField2()`：
- `public Predicate.Op getOperator()`：

Filter

- `public Filter(Predicate p, OpIterator child)`：
- `public Predicate getPredicate()`：
- `public TupleDesc getTupleDesc()`：
- `public void open()`：
- `public void close()`：
- `public void rewind()`：
- `protected Tuple fetchNext()`：
- `public OpIterator[] getChildren()`：
- `public void setChildren(OpIterator[] children)`：

Join

- `public Join(JoinPredicate p, OpIterator child1, OpIterator child2)`：
- `public JoinPredicate getJoinPredicate()`：
- `public String getJoinField1Name()`：
- `public String getJoinField2Name()`：
- `public TupleDesc getTupleDesc()`：
- `public void open()`：
- `public void close()`：
- `public void rewind()`：
- `protected Tuple fetchNext()`：
- `public OpIterator[] getChildren()`：
- `public void setChildren(OpIterator[] children)`：

IntegerAggregator：

- `public IntegerAggregator(int gbfield, Type gbfieldtype, int afield, Op what)`：
- `public void mergeTupleIntoGroup(Tuple tup)`：
- `public OpIterator iterator()`：

**Limit**

OrderBy只支持按一个字段进行排序。

## -------------------------------------------------------------

#### 查询处理的模型：

火山模型：或迭代模型。算子每次只处理并返回一个数据。

物化模型：算子每次处理完所有的数据并返回。

向量化模型：是一种折中的选择。算子每次处理一个batch的数据并返回。

查询的方向：自动顶向下的方向，父节点来调用子节点，自底向上，子节点来调用父节点。但是数据流永远都是自底向上的。

#### 访问方法

访问方法是DBMS访问表中数据的方法。有以下几种：顺序扫描，索引扫描，多索引扫描或位图扫描。它在查询计划中处理叶结点的位置。

顺序扫描的优化方法：

- prefetching：
- Buffer Pool Bypass：
- Parallelization：
- Heap Clustering：
- Zone Maps：提前给每个页计算一些统计信息。当查询的时候，DBMS就可以检查zone map来决定是否要读这个页。但是如何存储这个页的缓存信息呢？另外当页内的信息发生变化时，页的统计信息可能要改变更多。
- Late Materialization：

#### 带修改的查询

带修改的操作会修改数据库，这些算子会负责检查约束或更新索引。

#### 进程模型

- 一个worker作为一个进程
- 进程池
- 一个worker作为一个线程

